# The asynchronous drop glue generation design

This text aims to explain the design of [my asynchronous drop
prototype](https://github.com/rust-lang/rust/pull/121801), which I have
been working on for some time now.

## Public interface of `AsyncDrop`

I've tried to make interface of asynchronous drops as similar to the
synchronous drops as possible. Take a look at the definition of the most
important public trait of my prototype (`AsyncDrop` trait):

```rust
/// Custom code within the asynchronous destructor.
pub trait AsyncDrop {
    /// A future returned by the [`AsyncDrop::async_drop`] to be part
    /// of the async destructor.
    type Dropper<'a>: Future<Output = ()>
    where
        Self: 'a;

    /// Constructs the asynchronous destructor for this type.
    fn async_drop(self: Pin<&mut Self>) -> Self::Dropper<'_>;
}
```

Given that we don't have `async` as a keyword generic I've had to define
the entire new trait. It's kinda similar to [`AsyncFnMut`] as that
trait also mirrors [`FnMut`]. Both of these async traits use near to
the desugared interface of async functions, returning from sync method
a future object of trait's associated type. I've also wrapped mutable
reference to self into `Pin` just to be sure, maybe it'll become useful
or detrimental.

Let's imagine its implementation for a new, cancellable during drop task
handle in tokio:

```rust
impl<T> AsyncDrop for CancellableJoinHandle<T> {
    type Dropper<'a>: impl Future<Output = ()>;

    fn async_drop(self: Pin<&mut Self>) -> Self::Dropper<'_> {
        async move {
            self.join_handle.abort();
            let _ = Pin::new(&mut self.join_handle).await;
        }
    }
}
```

Here we are wrapping [`tokio::task::JoinHandle`] and using
[`JoinHandle::abort`] to cancel the task if possible, and then awaiting
its end. The `impl_trait_in_assoc_type` feature is used there to not
implement futures manually, perhaps this can be simplified further with
return-position `impl Trait` and async methods in traits.

## Asynchronous drop glue

To run async drop glue on a type we can use public `async_drop` or
`async_drop_in_place` functions, just as with the regular variant of drop.
These are the async implementations:

```rust
pub async fn async_drop<T>(to_drop: T) {
    let to_drop = MaybeUninit::new(to_drop);
    // SAFETY: we store the object within the `to_drop` variable
    unsafe { async_drop_in_place(to_drop.as_mut_ptr()).await };
}

pub unsafe fn async_drop_in_place<T: ?Sized>(
    to_drop: *mut T,
) -> <T as AsyncDestruct>::AsyncDestructor {
    // ...
}
```

I assume you understand how `async_drop` function works. However the
hard part lies with `async_drop_in_place`. It is not an async function
but merely returns an object of `AsyncDestruct::AsyncDestructor` type,
presumably a future. You can also notice we don't have syntax `T:
AsyncDestruct`. Let's take a closer look of `AsyncDestruct` trait and
its associated type:

```rust
trait AsyncDestruct {
    type AsyncDestructor: Future<Output = ()>;
}
```

This trait is internal to the compiler. The `AsyncDestructor` is
actually a future for async drop glue, the code deinitializing the
`Self` object. It is implemented for every type, thus it does not require
trait bounds to use on any type. Compiler implements it the same way as
the also internal [`DiscriminantKind`] trait. Now I should mention that
`async_drop_in_place`'s body is also generated by the compiler, but this
time it's the same way [`drop_in_place`] is generated (via shim).

But what type should we assign to `AsyncDestructor`? `async_drop_in_place`
simply creates that asynchronous destructor future and does not execute
it. I haven't yet found a way to generate coroutines solely from the
compiler, but I was given the advice to compose `core` library types to
create such futures. I've defined various future combinators to *chain*,
*defer* futures or to choose *either* of two futures and by combining
them I've implemented asynchronous destructors for ADTs and other
types. Although some code couldn't have been offloaded to the `core`
(I think). For example I've had to precompute a pointer to each field
ahead of time inside of the `async_drop` method.

```rust
// NOTE: For some reason this implementation currently does not pass
//   tests, so I've had to keep manually desugared version of it.
#[lang = "async_drop_chain"]
async fn chain<F, G>(first: F, second: G)
where
    F: IntoFuture<Output = ()>,
    G: IntoFuture<Output = ()>,
{
    first.await;
    second.await;
}

#[lang = "async_drop_either"]
async unsafe fn either<O: IntoFuture<Output = ()>, M: IntoFuture<Output = ()>, T>(
    other: O,
    matched: M,
    this: *mut T,
    discriminant: <T as DiscriminantKind>::Discriminant,
) {
    if unsafe { discriminant_value(&*this) } == discriminant {
        drop(other);
        matched.await
    } else {
        drop(matched);
        other.await
    }
}

#[lang = "async_drop_defer"]
async unsafe fn defer<T: ?Sized>(to_drop: *mut T) {
    unsafe { async_drop_in_place(to_drop) }.await
}
```

Since async drop glue could hypothetically in future be executed
automatically within the cleanup branches used for unwind, one property
I believe `AsyncDestructor` future should have is that instead of
panicking it must simply return `Poll::Ready(())` on every poll after
future completes. I've called this property *future idempotency* since
it makes sense and have a special *fuse* combinator wrap around any
regular future to have such guarantee.

As of right now (2024-03-29) async drop glue for coroutines (async blocks)
and dynamic types (`dyn Trait`) are not implemented. Coroutines have
their special code for generating even regular drop glue, extracting a
`coroutine_drop` branch from coroutine's MIR. Other person works on
it. For dynamic types support I have a hypothetical design which I'll
describe below. Automatic async drops at the end of the scope aren't
implemented too.

### Combinator table

|Combinator|Description|
|---|---|
|either|Used by async destructors for enums to choose which variant of the enum to execute depending on enum's discriminant value|
|chain|Used by async destructors for ADTs to chain fields' async destructors|
|fuse|Used by async destructors to return `Poll::Ready(())` on every poll after completion|
|nop|Used by async destructors for trivially destructible types|
|never|Used by async destructors for empty types like enums with zero variants|
|slice|Used by async destructors for slices and arrays|
|surface_async_drop_in_place|Used by async destructors to execute the surface level `AsyncDrop::Dropper` future of a type|
|surface_drop_in_place|Used by async destructors to execute the surface level `Drop::drop` of a type|

You might ask if we even need `Nop` combinator and can't we not
instantiate async destructor for trivially destructible types? But no,
this is not possible, since user may call `async_drop_in_place` on any
type, which has to return some future type.

See current implementations of these combinators inside of the
[library/core/src/future/async_drop.rs].

### Visibility problem

If you compare public interface for interacting with value discriminants
within the `core` library with interface described here, you could notice
usage of trait's associated type instead of a generic type. Actually
directly using this associated type may be problematic as it can possibly
leak its special trait and method implementations. Also I believe
it would be better to keep `AsyncDestruct` trait private. At last it
perhaps it would be more convenient to use a generic type instead as with
[`Discriminant`].

To solve this problem the only way right now would be to define a
wrapper struct `AsyncDropInPlace<T>` around it and forward its `Future`
implementation to the actual async destructor of type `T`. We would also
have a new wrapper function `async_drop_in_place` to return that wrapper
type and would rename compiler generated function which held this name
previously into `async_drop_in_place_raw`.

However, this `AsyncDropInPlace` could still leak some details of stored
inner value, such as any auto trait implementation and a drop check. These
can be either left as is (current behavior) or be suppressed with
`PhantomData<*mut ()>` field and with a nop `Drop` implementation on it.
Not sure which one should be chosen.

## What's next?

### ADT async destructor types

As I've said those future combinators are just a patchwork for
current inability to generate ADT futures on the fly. Defining such
components inside of the `core` is fine in some cases, like for
async destructor of slice. But for ADTs, tuples, closures the proper
solution would be to define the new [type kind] named something like
`AdtAsyncDestructor`. Given one of those types we could generate
a consistent state for the async destructor and then generate its
`Future::poll` function. This way we won't need to calculate and store
all the pointers to each field ahead of time.

## Ideas

### `async_drop_in_place` should work with references?

Since `async_drop_in_place` returns an async destructor future what should
reference the dropped object, perhaps it would be more beneficial to have
`async_drop_in_place` use reference `&mut ManuallyDrop<T>` instead. It
would be less unsafe and we won't have to deal with pointers infecting
async destructor types with `!Send` and `!Sync`.

### Async drop glue for `dyn Trait`

The problem with dynamic types is basically about
loosing the type information. We cannot know `<dyn Trait as
AsyncDestruct>::AsyncDestructor` type's size and alignment, thus we
[cannot](https://github.com/rust-lang/rust/issues/48055) know how much
stack or coroutine's local space we should allocate for the storage. One
approach would be to have `type AsyncDestructor = Box<dyn Future>`
for dynamic types, which could be not ideal. But actually before we
coerce static types into dynamic, perhaps we could have a wrapper
type which contains space both for `T` and for `<AsyncDestruct as
T>::AsyncDestructor`?

```rust
trait PollDestruct {
    fn poll_drop(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()>;
}

struct PollDrop<T> {
    async_dtor: Option<<T as AsyncDestruct>::AsyncDestructor>,
    value: MaybeUninit<T>,
    _pinned: PhantomPinned,
}

impl<T> PollDestruct for PollDrop<T> {
    fn poll_drop(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        unsafe {
            let this = self.get_unchecked_mut();
            let dtor = this
                .async_dtor
                .get_or_insert_with(|| async_drop_in_place(this.value.as_mut_ptr()));
            Pin::new_unchecked(dtor).poll(cx)
        }
    }
}

// Have a `PollDrop<Fut> -> Box<dyn Future<Output = ()> + PollDestruct>`
```

And like that we embedded enough space and type information to
unsize these types and work with them, while still being able to be
asynchronously destroyed.

### Implicit cancellation points

WIP

```rust
{
    let x = AsyncStruct::new();
} await
```

## Unanswered questions

### Drop of async destructors

## Conclusion

There are still a lot of questions to be answered, but it's important
to not put our hands down.

[`drop_in_place`]: https://doc.rust-lang.org/1.77.0/src/core/ptr/mod.rs.html#507-513
[`DiscriminantKind`]: https://doc.rust-lang.org/1.77.0/src/core/marker.rs.html#881-886
[`AsyncFnMut`]: https://doc.rust-lang.org/1.77.0/std/ops/trait.AsyncFnMut.html
[`FnMut`]: https://doc.rust-lang.org/1.77.0/std/ops/trait.FnMut.html
[`tokio::task::JoinHandle`]: https://docs.rs/tokio/1.36.0/tokio/task/struct.JoinHandle.html
[`JoinHandle::abort`]: https://docs.rs/tokio/1.36.0/tokio/task/struct.JoinHandle.html#method.abort
[library/core/src/future/async_drop.rs]: https://github.com/zetanumbers/rust/blob/async_drop_glue/library/core/src/future/async_drop.rs
[`Discriminant`]: https://doc.rust-lang.org/1.77.1/core/mem/struct.Discriminant.html
[type kind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/ty_kind/enum.TyKind.html
